#labels Phase-Design,Phase-Implementation,Phase-Requirements
All Eyes is an intrusion detection monitor that can scale from tiny embedded system to Enterprise server.

= Introduction =
“All Eyes” (AKA ae) is a miniature applications-security intrusion detection system.  It has three components.  They are:
     1.  'ae' daemon that spawn and maintains monitors (Implemented in C)
     2.  Monitors are independent programs that monitor various critical components of a system such as Sockets, running-processes, critical files etc. (Implemented in C)

     3.  'ae-mgr' is an Android application helps users to choose various action for ae to take, based on the status of the monitors. (Implemented in Java)

= ae Architecture =

= ae-Monitor Communication =

= ae - aemgr Communication =


monitor framework. This flexible framework can be configured at compile time with necessary application security monitors such as:
- Self-monitor – monitors itself to ensure it is running and not killed
- Open sockets (any un desirable ones open, required ones are really open etc)
- File descriptors, critical binaries(signs it and makes sure it does not change)
- Critical files such as /etc/passwd, /etc/hosts
- More monitors can be added by others as needed.
Based on the report, ae will take one or more of predefined actions in the framework; actions are also extendable. All actions will be approved by a mobile client ‘aemgr’ i.e. an Android mobile application. Android mobile application will communicate to ae, through a proxy server using SSL.
‘ae’ will run in a chroot-jailed environment, with AppArmor protection, only over SSL.
This application is targeted to work from a small-scale embedded processor to large scale server.
‘ae’ can run only in monitor/report mode or monitor/report/take action upon approval mode. It also works in ‘persistent mode” means the signature of files are kept across system reboot or in “volatile mode” in which the signature of the critical binaries are calculated upon each reboot and monitored until next reboot.
‘ae’ will have three levels of security (trust): SSL, chroot-jail and AppArmor.





= Details =
Overall ae design
Put Todd’s picture.
Components Descriptions
‘ae’….
‘ae’ monitors
‘aemgr’
‘proxy’
How to setup development Environment
ae (Ubuntu Linux environment)
- Need Linux development environment; Makefile is provided.    Just type "make" in src/ae directory.
- One can also use Eclipse; will be easier to develop  as we are sync'ing with google-code SVN.
- Make sure syslog service is running to see the logs in /var/log/messages.

ae server
    'ae' is a dynamically linked for security.  Each Monitor is a plugin at compile time.  Monitors are spawned as threads with two parameters i.e. to act in monitor mode/minitor-and-action mode and the lifespan is persistent/volatile across reboots.  How a monitor keeps its information in persistent is upto the monitor.  But, actions are predefined in the framework.  Monitors can't take actions.  They can only update the status level.
Proxy
Proxy is…
Aemgr
Aemgr is an Android App…



    Future ae Enhancements:
-	Instead of spawning threads, run each monitor in its own  address space i.e. use fork, instead of spawning threads.  NOTE:  If you do, you will have to develop IPC mechanism to talk to the monitors.
-	Make PERSISTENT/VOLATILE per Monitor based, not ae wide.
-	Make 'ae' statically linked for embedded environment.
-	Add Mutex to protect the monitor struct.


How to add Monitor-Plugins to ae
-	Add the MONCOMM structure values in ae.c to monarray structure array.
-	Add a .c file by our monitor name (EX: selfmon.c) with appropriate functions.
-	Add your monitor function with the apprpriate prototype in ae.h.




Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages