=PROCEDURE FOR WRITING A MONITOR=

==How the ae daemon execs the monitor==
# For monitor written in C and integrated as part of ae daemon, you write the monitor and compile it as a object file that is linked with the ae daemon together.
# For monitor written in other language, like Perl, Python, Shell script, you write the monitor to be a stand-alone process which is spawned by the ae daemon.
# Yes, you can write the stand-alone monitor in C as well.

==Procedure of writing the monitor==
# You create a monitor directory under ../src/ae, say the name is *_mymon_*.
# Copy the wrapper code, which is a C language template, from an existing monitor and rename it to be *_mymon.c_*. The wrapper code is similar to the code segment below:

||int checksum_check(void) { return(0) }||
||void mymon (int mode) {||
||    if (checksum_check() != 0) {||
||        aeLOG("socketmon-c:  socket monitor: exec failed due to bad checksum\n");||
||        exit(1);||
||}||
||#ifdef DEBUG||
||    if (execl("/usr/bin/perl", " ", "mymon.pl",  NULL) < 0) {||
||#else||
||    if (execl("/usr/bin/perl", " ", "/bin/mymon.pl", NULL) < 0) {||
||#endif||
||        aeLOG("sockmon-c:  socket monitor: exec failed,  Exit Code: %d\n", errno);||
||        exit(1);||
||    }||
||    exit(2);||
||}||



      # The communication is via STDIN and STDOUT. The monitor should use STDERR for displaying its internal message
      # Use the defined ae/monitor protocol 
      # Makefile template. This includes the sha256sum to generate the checksum for monitor written in language other than C
      # Modification to the ae daemon files to include the monitor
==Testing==
      # For stand-alone monitor written in language other than C (yes, the stand-alone monitor can be written in C as well), you can test it by running the monitor stand-alone by (1) use the keyboard for entering the message that will be sent to the monitor, (2) the output message from monitor will be displayed on screen.
      # For non stand-alone monitor (written in C), the testing must be done with the ae daemon together.

-----------------------------------------------------
====THE FOLLOWING IDEA IS NOT CARRIED OUT====
The monitor can be written in any languages including C, Perl, Python, etc. There is a standard procedure for writing a good monitor as defined below:

   # The input parameters that the monitor should expect are listed in the order as
         # TCP port number _*`tcp-port`*_
         # The public prime number _*`p`*_ of the Diffie-Hellman key exchange algorithm
         # The public base number _*`b`*_ of the Diffie-Hellman key exchange algorithm
         # The public key _*`A`*_ of the Diffie-Hellman key exchange algorithm
   # The monitor listens on the port _*`tcp-port`*_ for incoming conenctions. The monitor calculates its public/private key pair based on the _*`p`*_, _*`b`*_, and _*`A`*_ values using the Diffie-Hellman key exchange algorithm. Note that the monitor should only support 1 connection.
   # If there is no incoming connection for 30 seconds, the monitor should kill itself.
   # After the connection is established, the monitor sends out the initial channel validation message (see the page AeMonitorProtocol for more information). This mesage should include the monitor's public key _*`B`*_.
   # If there is no response message after 30 seconds of sending out the initial channel validation message, the monitor should kill itself.
   # All messages after receiving the first ACK message should be encrypted by AES.
   # The monitor should send out the HELLO message every 30 seconds and expect to receive the ACK response message. If the ACK response message isn't received within 30 seconds, the monitor should kill itself.
   # At anytime, if the monitor detects the connection is broken, the monitor should kill itself.

The complete protocol between the monitor and remote ae-daemon is defined in the page AeMonitorProtocol.

The monitor programmer should make sure the proper Makefile(s) are updated to include

   * Run SH256 to generate the proper checksum and save it to the monitor checksum profile.
   * Generate the `AppArmor` profiles for all monitor files.
   * Copy the monitor files to proper production directories.
   * Copy the `AppArmor` profiles to proper `AppArmor` production directories.