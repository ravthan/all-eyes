=PROCEDURE FOR WRITING A MONITOR=

==Integrated or Stand-alone Monitor==
   # For monitors written in C and integrated as part of ae daemon, you write the monitor and compile it as a object file that is linked with the ae daemon together.
   # For monitors written in other languages, like Perl, Python, Shell script, you write the monitor to be a stand-alone process which is spawned by the ae-daemon.
   # Yes, you can write the stand-alone monitor in C as well.

==Procedure of writing the monitor==
   # Create a monitor directory under *_../src/ae_*, say the name is *_mymon_*.
   # Copy the wrapper code, which is a C language template, from an existing monitor and rename it to be *_mymon.c_*.
   # The monitor sends message to ae-daemon by writing the message to STDOUT and receives message from ae-daemon by reading the message from STDIN. The monitor should use STDERR for displaying its internal message
   # The monitor message protocol is defined in page *AeMonitorProtocol*
   # Copy the *_Makefile_* template from an existing monitor. This file includes the *_sha256chk_* to generate the sha256 checksum for monitor written in language other than C.
   # Modify the *_Makefile_* to include the *_mymon_* file(s)
   # Modify following files under *_../ae/src/daemon_*:
         * *_aeconfig.c_*  - to include the *_mymon_* structure
         * *_aedaemon.h_*  - increase the total number of monitor structure counter *_MAXMONITORS_*
   # Modify the file *_../ae/src/include/ae.h_* to declare *_mymon_* there
==Testing==
   # For stand-alone monitor written in language other than C (yes, the stand-alone monitor can be written in C as well), you can test it by running the monitor stand-alone by (1) use the keyboard for entering the message that will be sent to the monitor, (2) the output message from monitor will be displayed on screen.
   # For non stand-alone monitor (written in C), the testing should be done with the ae-daemon together.

-----------------------------------------------------
====THE FOLLOWING IDEA IS NOT CARRIED OUT====
The monitor can be written in any languages including C, Perl, Python, etc. There is a standard procedure for writing a good monitor as defined below:

   # The input parameters that the monitor should expect are listed in the order as
         # TCP port number _*`tcp-port`*_
         # The public prime number _*`p`*_ of the Diffie-Hellman key exchange algorithm
         # The public base number _*`b`*_ of the Diffie-Hellman key exchange algorithm
         # The public key _*`A`*_ of the Diffie-Hellman key exchange algorithm
   # The monitor listens on the port _*`tcp-port`*_ for incoming conenctions. The monitor calculates its public/private key pair based on the _*`p`*_, _*`b`*_, and _*`A`*_ values using the Diffie-Hellman key exchange algorithm. Note that the monitor should only support 1 connection.
   # If there is no incoming connection for 30 seconds, the monitor should kill itself.
   # After the connection is established, the monitor sends out the initial channel validation message (see the page AeMonitorProtocol for more information). This mesage should include the monitor's public key _*`B`*_.
   # If there is no response message after 30 seconds of sending out the initial channel validation message, the monitor should kill itself.
   # All messages after receiving the first ACK message should be encrypted by AES.
   # The monitor should send out the HELLO message every 30 seconds and expect to receive the ACK response message. If the ACK response message isn't received within 30 seconds, the monitor should kill itself.
   # At anytime, if the monitor detects the connection is broken, the monitor should kill itself.

The complete protocol between the monitor and remote ae-daemon is defined in the page AeMonitorProtocol.

The monitor programmer should make sure the proper Makefile(s) are updated to include

   * Run SH256 to generate the proper checksum and save it to the monitor checksum profile.
   * Generate the `AppArmor` profiles for all monitor files.
   * Copy the monitor files to proper production directories.
   * Copy the `AppArmor` profiles to proper `AppArmor` production directories.