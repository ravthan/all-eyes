=PROCEDURE FOR WRITING A MONITOR=

==Integrated or Stand-alone Monitor==
   # For monitors written in C and integrated as part of 'ae' daemon, write the monitor and compile it as a object file that is linked with the 'ae' daemon together.
   # For monitors written in languages, like Perl, Python, Shell, Java script, write the monitor to be a stand-alone process.  In the same directory of the monitor, there is a small C file that acts as the wrapper between the monitor and the 'ae' daemon. This C file calls the monitor and is compiled as a object file to be linked with the 'ae' daemon.
   # For stand-alone monitor, the Makefile under the same monitor directory calculates the SHA256 checksum of the stand-alone monitor and its related files. The checksum values are compiled into the small C file, the wrapper code, and linked with the 'ae' daemon. When the 'ae' daemon spawns the stand-alone monitor, it will recalculate the checksum(s) can compare the checksum values before launching the stand-alone monitor.

==Procedure of writing the monitor==
To explain the process more clearly, let's use the an example of writing a stand-alone monitor called *_mymon_*.
   # Create a monitor directory under *_all-eyes/src/ae_*, say the name is *_mymon_*.
   # Copy the c file, the wrapper, from the existing directory *_socketmon/socketmon.c_* and rename it to be *_mymon.c_*. Modify the file to replace the word socketmon to be mymon.
   # Copy the file Makefile from the existing directory *_socketmon/Makefile_*. Modify the file to replace the file names to be the file names for *_mymon_*. Please note that the *_Makefile_* includes the *_sha256chk_* to generate the sha256 checksum.
   # Create the file the stand-alone monitor source file named *_mymon.{ext}_*. Please refer to the existing monitor code for how to write the monitor flow. The heat of the monitor is to send and receive message to/from 'ae' daemon where the monitor sends message to 'ae' daemon by writing the message to STDOUT and receives message from 'ae' daemon by reading the message from STDIN.
   # Please note that the monitor should use STDERR for displaying its internal message. This is because the STDOUT and STDIN have been consumed for communicating with the 'ae' daemon.
   # The monitor message protocol is defined in page *AeMonitorProtocol*
   # Modify the following files under *_all-eyes/src/ae/daemon_*:
         * *_aeconf.h_*  - to include the *_mymon_* structure
         * *_aedaemon.h_*  - increase the total number of monitor structure counter *_MAXMONITORS_*
   # Modify the file *_all-eyes/src/ae/include/ae.h_* to declare *_mymon_* there

==Monitor Configuration File==
In case that the monitor needs to read its configuration file, this configuration file should be placed in directory *_/etc/ae/_*. This directory is a common place for all monitor configuration files.

==Testing==
   # For stand-alone monitor written in language other than C (yes, the stand-alone monitor can be written in C as well), you can test it by running the monitor stand-alone by (1) use the keyboard for entering the message that will be sent to the monitor, (2) the output message from monitor will be displayed on screen.
   # For non stand-alone monitor (written in C), the testing should be done with the ae-daemon together.

-----------------------------------------------------
====THE FOLLOWING IDEA IS NOT CARRIED OUT====
The monitor can be written in any languages including C, Perl, Python, etc. There is a standard procedure for writing a good monitor as defined below:

   # The input parameters that the monitor should expect are listed in the order as
         # TCP port number _*`tcp-port`*_
         # The public prime number _*`p`*_ of the Diffie-Hellman key exchange algorithm
         # The public base number _*`b`*_ of the Diffie-Hellman key exchange algorithm
         # The public key _*`A`*_ of the Diffie-Hellman key exchange algorithm
   # The monitor listens on the port _*`tcp-port`*_ for incoming conenctions. The monitor calculates its public/private key pair based on the _*`p`*_, _*`b`*_, and _*`A`*_ values using the Diffie-Hellman key exchange algorithm. Note that the monitor should only support 1 connection.
   # If there is no incoming connection for 30 seconds, the monitor should kill itself.
   # After the connection is established, the monitor sends out the initial channel validation message (see the page AeMonitorProtocol for more information). This mesage should include the monitor's public key _*`B`*_.
   # If there is no response message after 30 seconds of sending out the initial channel validation message, the monitor should kill itself.
   # All messages after receiving the first ACK message should be encrypted by AES.
   # The monitor should send out the HELLO message every 30 seconds and expect to receive the ACK response message. If the ACK response message isn't received within 30 seconds, the monitor should kill itself.
   # At anytime, if the monitor detects the connection is broken, the monitor should kill itself.

The complete protocol between the monitor and remote ae-daemon is defined in the page AeMonitorProtocol.

The monitor programmer should make sure the proper Makefile(s) are updated to include

   * Run SH256 to generate the proper checksum and save it to the monitor checksum profile.
   * Generate the `AppArmor` profiles for all monitor files.
   * Copy the monitor files to proper production directories.
   * Copy the `AppArmor` profiles to proper `AppArmor` production directories.