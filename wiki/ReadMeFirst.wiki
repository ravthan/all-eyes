= Motivation behind this project =
Perfect security is a myth.  Most unbreakable security of today, ages to vulnerability over time.  Hence taking quick action after a security breach is critical.  Having a security layer along defensive lines, i.e. doing passive/active monitoring of critical components and taking actions based on configurable thresholds provides such a mitigation, against a possible security breach.
"AllEyes" is such a framework with a potpourri of tools (monitors) useful for defenders, attackers and security professionals.

The plan is to ensure the scalability of AllEyes from small embedded systems to large scale servers. 

For the NYU-POLY Application Security class project, we prototyped the concept on Ubuntu.

= Introduction =
“All Eyes” (AKA ae) is a miniature applications-security intrusion detection system.  It has four components.  They are:

   # 'ae' daemon that spawns and maintains monitors.  This component is implemented in C.  This component executes from the host, outside of chroot-jail.  Then it drops the privileges and spawns monitors to run within the chroot-jail.
   #  Monitors are independent processes spawned by the ae daemon. Each monitor watches a class of a system resources such as Sockets, running-processes, critical files etc. Monitors may be implemented in C or in other languages such as PERL, PYTHON, Java etc.
   #  'ae proxy' acts as a DMZ between the Android ae-Manager and the ae daemon.
   #  'ae-mgr' is an Android application which helps users to choose various actions for ae daemon to take, based on the status of the monitors. It communicates over the Internet to ae daemon through a secure connection.  This component is implemented in Java.


= High Level Architecture =

Following is an overview diagram of the AE architecture:
http://all-eyes.googlecode.com/svn/trunk/docs/AEArchOverView.png


==1) Linux System (ae daemon):==

   Running on Ubuntu 12.04 (Precise Pangolin) release, consists of a main daemon, which communicates with monitors.  The communication between ae daemon and a monitor happens over socketpair; daemon sets up the stdin/sedout of the monitor to be the socket file descriptor to communicate.    The
   daemon will 'load' the monitors (via exec??)

    'ae' daemon entertains only one client at any given time.

    monitors are sent sigterm signal (KILL -9) if ae-daemon encounters issue with that monitor.

    This design assumes monitors are not hostile to each other and ae-daemon.
  
   The current prototyped monitors are:
     * self monitor 
     * socket monitor 
     * process monitor
     * file descriptor monitor
     * critical file monitor


     The procedure for creating a monitoring is defined here:
     http://code.google.com/p/all-eyes/wiki/MonitorProcedure

    Protocol between daemon & monitors is described here:

      https://code.google.com/p/all-eyes/wiki/AeMonitorProtocol

    The ae-daemon will run in chroot, the installation package with set this up for the user.  Following is information on how to setup chroot:
     http://code.google.com/p/all-eyes/wiki/ChrootSetup

==2) Web Server(AE Proxy):==

    The AE proxy will translate packets between the AE and AE Manger(running on Droid Device)

     SSL is used for the communications, for creating the key files for this application, see:

     http://code.google.com/p/all-eyes/wiki/KeyManagementTool

*///TBRT_QUESTION... Need more details here///*

==3) Android Device(AE Manager):==

   The Android Device will obtain status on the various monitors.
*///TBRT_QUESTION... Need more details here///*

==4) Communication between AE and Monitors:==
    Explain about streams based socketpair communication.
*///TBRT_QUESTION... Need more details here///*

==5) Communication between AE and AE Proxy:==

    The communication between AE & AE Proxy will be over SSL.

    The specific protocol is defined here:
http://code.google.com/p/all-eyes/wiki/AeClientProtocol

*///TBRT_QUESTION... Is the above correct?  Does AeClientProtocol define this connection between daemon and proxy, or end to end between daemon and android client?///* 

*///TBRT_QUESTION... Link to toms page///*

==6) Communication between AE Proxy and AE Manger==

    The communication between AE & AE Proxy will be over SSL.
*///TBRT_QUESTION... Need more details here///*



=Implementation/Testing=

==1) Development Environments:==

  a) AE:

     *Add detail about apt-get install of SVN package.*
     Utilizes google svn, located at:

         https://code.google.com/p/all-eyes/source/browse/

     Users may use CLI/command line access for their developers
     environment, or use eclipse as described:

      https://code.google.com/p/all-eyes/wiki/EclipseC_SVNSetup

     Requires installation of SSL:
http://code.google.com/p/all-eyes/wiki/UbuntuSSLsetup
*///TBRT_QUESTION:  Is the above true, is the UbuntuSSLsetup for development or production?///*

   b) AE Proxy:

*///TBRT_QUESTION... Need more details here///*   

   c) AE Manager:

     Additional information can be found here:
     http://code.google.com/p/all-eyes/wiki/AndroidDevelopmentEnvironmentSetup

*///TBRT_QUESTION... Need more details here///*

==2) Testing==
  a) We have been doing incremental testing through out the development cycle (running ae daemon regression test after every couple of builds helps us iron out bugs before going on to far.)

  The details of issues/bugs found are documented in [http://code.google.com/p/all-eyes/issues/list].  We are continuously resolving the bugs and adding code towards enhancements.


==3) Coding Styles==

*///TBRT_NOTE:  Link or description of our coding styles...////*

  # Function type & name on same line:
     int functionA(int A, int B)
  #  All defined variables will be assigned a default value:
     int i = 1, j = -1;
  #  Indentation, users are encouraged to indent their code for easy reading:
{{{
int functionA(void)
{
   int ret=0;
       
   printf("Hello\n");
   return(0);
}
}}}
  # Comments:
   * Before every function.
   * Located at right hand side of statements.
   * In general, when in doubt, comment.
  # Security:  Add SECURITY comment when have a security concern.


*///TBRT_QUESTION:  Is this where we will describe compile/link options used for a) security of executables  and b) code checking...

==4) Security==

     #Where we have Security concerns, we have added "Security" keyword in the code.

==5) Future Enhancements==


  # Make PERSISTENT/VOLATILE per Monitor based, not ae wide.
  # Make 'ae' statically linked for embedded environment.
  # Add Mutex to protect the monitor struct.
  # Make sure restarting of the Monitors work properly.
  # Add support for all signals.
  # Give each message from Monitor an ID (per monitor basis)
  # Give monitor the ability to define what action should be taken based on the abnormality
  # Do security analysis of whether different protocol is necessary between the aedaemon-and-AeManager( SSL client) and aedaemon-and-Monitors




==6) Known Issues==

   #  When Monitor dies, it sends signal to parent (ae-daemon), ae-daemon is supposed to act on the signal, but it does not seem to be working in Ubuntu (it is staying in defunct state).

   #  When monitor dies, it cannot be restarted.


==7) Installation==

*/// TBD. Two installation options ///*
    
   #   Three tar files, plus Short Installation Doc.
   #  Install Package.

A.  ae-daemon, which dir(s) installed to?

B.  proxy, which dir(s) installed to?
      Running under same VM as ae-daemon (for prototype), outside of chroot directory.

C.  droid app, which dir(s) installed to?
      Running under same VM (for prototype)