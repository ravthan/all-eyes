= Introduction =
“All Eyes” (AKA ae) is a miniature applications-security intrusion detection system.  It has four components.  They are:

   #'ae' daemon that spawns and maintains monitors (Implemented in C)
   #  Monitors are independent programs that monitor various critical components of a system such as Sockets, running-processes, critical files etc. (Implemented in C)
   #  'ae proxy' will translate packets between the ae daemon and ae manger(running on Droid Device)
   #  'ae-mgr' is an Android application helps users to choose various action for ae to take, based on the status of the monitors. It communicates over the Internet to ae through a secure connection (Implemented in Java).



= Details =

Following is an overview diagram of the AE architecture:
http://all-eyes.googlecode.com/svn/trunk/docs/AEArchOverView.png



=1) Embedded System (ae daemon):=

   Running on Ubuntu 12.04 (Precise Pangolin) release, consists of a main daemon, which communicates
   with 1 or more monitors.  This communication is via stdin/stdout.  The
   daemon will 'load' the monitors (via exec??)

    'ae' daemon entertains only one client at any given time.
  
   The current monitors supported are:

    # self monitor 
    # socket monitor 
    # file 
    # critical file monitor tbd

*////BLAIR_QUESTION... We need to firm this up for what we have in the prototype////*

     The procedure for creating a monitoring is defined here:
     http://code.google.com/p/all-eyes/wiki/MonitorProcedure

    Protocol between daemon & monitors is described here:

      https://code.google.com/p/all-eyes/wiki/AeMonitorProtocol

    The ae-daemon will run in chroot, the installation package with set this up for the user.  Following is information on how to setup chroot:
     http://code.google.com/p/all-eyes/wiki/ChrootSetup

=2) Communication between AE and AE Proxy:=

    The communication between AE & AE Proxy will be over SSL.

    The specific protocol is defined here:
http://code.google.com/p/all-eyes/wiki/AeClientProtocol

*///BLAIR_QUESTION... Is the above correct?  Does AeClientProtocol define this connection between daemon and proxy, or end to end between daemon and android client?///*

=3) Web Server(AE Proxy):=

    The AE proxy will translate packets between the AE and AE Manger(running on Droid Device)

     SSL is used for the communications, for creating the key files for this application, see:

     http://code.google.com/p/all-eyes/wiki/KeyManagementTool

*///BLAIR_QUESTION... Need more details here///*

=4) Communication between AE Proxy and AE Manger=

    The communication between AE & AE Proxy will be over SSL.
*///BLAIR_QUESTION... Need more details here///*

=5) Android Device(AE Manager)=

   The Android Device will obtain status on the various monitors.

   

*///BLAIR_QUESTION... Link to toms page///*

=6) Development Environments:=

  a) AE:

     Utilizes google svn, located at:

         https://code.google.com/p/all-eyes/source/browse/

     Users may use CLI/command line access for their developers
     environment, or use eclipse as described:

      https://code.google.com/p/all-eyes/wiki/EclipseC_SVNSetup

     Requires installation of SSL:
http://code.google.com/p/all-eyes/wiki/UbuntuSSLsetup
*///BLAIR_QUESTION:  Is the above true, is the UbuntuSSLsetup for development or production?///*

   b) AE Proxy:

*///BLAIR_QUESTION... Need more details here///*   

   c) AE Manager:

     Additional information can be found here:
     http://code.google.com/p/all-eyes/wiki/AndroidDevelopmentEnvironmentSetup

*///BLAIR_QUESTION... Need more details here///*

=7) Testing=
  a) We have been doing incremental testing through out the development cycle (running ae daemon regression test after every couple of builds helps us iron out bugs before going on to far.)

  The details of issues/bugs found are documented in [http://code.google.com/p/all-eyes/issues/list].  We are continuously resolving the bugs and adding code towards enhancements.


=8) Coding Styles=

*///BLAIR_NOTE:  Link or description of our coding styles...////*

# Function return value/void on same line:

   int functionA(int A, int B)

#  All local variables will be assigned a default value:

   int i = 1, j = -1;


*///BLAIR_QUESTION:  Is this where we will describe compile/link options used for a) security of executables  and b) code checking...


=9) Future Enhancements=

  #Instead of spawning threads, run each monitor in its own  address space i.e. use fork, instead of spawning threads.  NOTE:  If you do, you will have to develop IPC mechanism to talk to the monitors.
  #Make PERSISTENT/VOLATILE per Monitor based, not ae wide.
  #Make 'ae' statically linked for embedded environment.
  #Add Mutex to protect the monitor struct.